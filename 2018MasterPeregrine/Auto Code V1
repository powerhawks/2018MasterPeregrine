	// positions referred to as A (left), B (middle) and C (right)
	/** Drives to Baseline from Driver station for either pos A or C */
	public void ACBaseline() {
		driveTrain.driveDistance(-Dimensions.G_DS_TO_BL_DIST); // might not be
																// long enough
	}

	/** puts cube in left side of switch from pos A */
	public void ASwitchLeft() {
		driveTrain.driveDistance(Dimensions.G_DS_TO_M_SW_DIST);
		driveTrain.turnTo(Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(ultrasonics[0].getDistance());
		shooter.shoot(shooter.SWITCH_VELOCITY, true);
	}

	/**
	 * @param side
	 *            R for right, L for left puts cube in switch from pos B
	 */
	public void BSwitch(char side) {
		int s;
		if (side == 'L') {
			s = -1;
		} else {
			s = 1;
		}
		driveTrain.driveDistance(Dimensions.STARTING_DISTANCE);
		driveTrain.turnTo(s * 49.68);
		driveTrain.driveDistance(204.02);
		driveTrain.turnTo(Dimensions.NINTEY_DEGREE_TURN);
		shooter.shoot(shooter.SWITCH_VELOCITY, true);
	}

	/** puts cube in right side of switch from pos C */
	public void CSwitchRight() {
		driveTrain.driveDistance(Dimensions.G_DS_TO_M_SW_DIST);
		driveTrain.turnTo(-Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(ultrasonics[0].getDistance());
		shooter.shoot(shooter.SWITCH_VELOCITY, true);
	}

	/**
	 * @param side
	 *            1 for right, -1 for left puts cube in desired side of Scale
	 *            from point (30 from wall, middle of switch)
	 */
	public void Scale(int side) {
		driveTrain.driveDistance(Dimensions.G_DS_TO_M_DIST - Dimensions.G_DS_TO_M_SW_DIST);
		driveTrain.turnTo(side * Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(30);
	}
	public void leftToRightScaleBehind() {
		driveTrain.driveDistance(Dimensions.G_DS_TO_M_SW_DIST + Dimensions.HALF_BLOCKS_TO_PLATFORM);
		driveTrain.turnTo(-Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.G_WIDTH_OF_FIELD_DIST - ultrasonics[0].getDistance());
		driveTrain.turnTo(Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.HALF_BLOCKS_TO_PLATFORM + (Dimensions.PLATFORM_TO_MIDDLE));
		driveTrain.turnTo(Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.FP_TO_SC_DIST / 2);
	}

	public void RightToLeftScaleBehind() {
		driveTrain.driveDistance(Dimensions.G_DS_TO_M_SW_DIST + Dimensions.HALF_BLOCKS_TO_PLATFORM);
		driveTrain.turnTo(-Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.G_WIDTH_OF_FIELD_DIST - ultrasonics[0].getDistance());// back
		driveTrain.turnTo(Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.HALF_BLOCKS_TO_PLATFORM + (Dimensions.PLATFORM_TO_MIDDLE));
		driveTrain.turnTo(-Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.FP_TO_SC_DIST / 2);
		shooter.shoot(shooter.SCALE_VELOCITY, true);
	}

	public void middleSwitchRight() {
		/** change temp to tempSensor or tempUltrasonic **/
		driveTrain.driveDistance(Dimensions.STARTING_DISTANCE);
		double tempAngle = Dimensions.hypAngleOppSide(ultrasonics[0].getDistance());// right
		double tempDistance = Dimensions.hypOppSide(ultrasonics[0].getDistance()); // right
		driveTrain.turnTo(-tempAngle);
		driveTrain.driveDistance(tempDistance);
		driveTrain.turnTo(tempAngle + Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.G_HALF_SW_LENGTH);
		shooter.shoot(shooter.SWITCH_VELOCITY, true);
	}

	public void middleSwitchLeft() {
		/** change temp to tempSensor or tempUltrasonic **/
		driveTrain.driveDistance(Dimensions.STARTING_DISTANCE);
		double tempAngle = Dimensions.hypAngleOppSide(ultrasonics[0].getDistance());// left
		double tempDistance = Dimensions.hypOppSide(ultrasonics[0].getDistance());// left
		driveTrain.turnTo(tempAngle);
		driveTrain.driveDistance(tempDistance);
		driveTrain.turnTo(-tempAngle + Dimensions.NINTEY_DEGREE_TURN);
		driveTrain.driveDistance(Dimensions.G_HALF_SW_LENGTH);
		shooter.shoot(shooter.SWITCH_VELOCITY, true);
	}